library(reticulate)
?reticulate
# Chunk 1: setup
knitr::opts_chunk$set(warning = F, message = F, dev = "svg", fig.align = "center")
#knitr::opts_chunk$set(tidy = T)
knitr::opts_chunk$set(comment = '#>')
options(digits = 2)
# Chunk 2
# allows us to run our stuff in python
library(reticulate)
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
# Chunk 3
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
boston = load_boston()
col_names = boston['feature_names']
bos = pd.DataFrame(data = boston['data'], columns = boston['feature_names'])
bos_target = boston['target']
#Check missing values.
bos.isnull().sum()
_ = bos.hist(bins=50, figsize = (20,15))
plt.show()
boston = load_boston()
col_names = boston['feature_names']
bos = pd.DataFrame(data = boston['data'], columns = boston['feature_names'])
bos_target = boston['target']
#Check missing values.
bos.isnull().sum()
_ = bos.hist(bins=50, figsize = (20,15))
plt.show()
knitr::opts_chunk$set(warning = F, message = F, dev = "svg", fig.align = "center")
#knitr::opts_chunk$set(tidy = T)
knitr::opts_chunk$set(comment = '#>')
options(digits = 2)
# allows us to run our stuff in python
library(reticulate)
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
update.packages("reticulate")
install.packages("reticulate")
install.packages("reticulate")
# Chunk 1: setup
knitr::opts_chunk$set(warning = F, message = F, dev = "svg", fig.align = "center")
#knitr::opts_chunk$set(tidy = T)
knitr::opts_chunk$set(comment = '#>')
options(digits = 2)
# Chunk 2
# allows us to run our stuff in python
library(reticulate)
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
# allows us to run our stuff in python
library(reticulate)
use_condaenv("miner")
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
# allows us to run our stuff in python
library(reticulate)
use_virtualenv("miner")
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
# allows us to run our stuff in python
library(reticulate)
use_condaenv("miner")
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
knitr::opts_chunk$set(warning = F, message = F, dev = "svg", fig.align = "center")
#knitr::opts_chunk$set(tidy = T)
knitr::opts_chunk$set(comment = '#>')
options(digits = 2)
# Chunk 1: setup
knitr::opts_chunk$set(warning = F, message = F, dev = "svg", fig.align = "center")
#knitr::opts_chunk$set(tidy = T)
knitr::opts_chunk$set(comment = '#>')
options(digits = 2)
# Chunk 2
# allows us to run our stuff in python
library(reticulate)
use_condaenv("miner")
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
reticulate::py_config()
# allows us to run our stuff in python
library(reticulate)
use_condaenv("miner")
sklearn <-import("sklearn")
# this set of functions allows us to autoincrement our figures
counter <- function() {
x <- 0
return (
function() {
# Assigning outside of scope! The real purpose of <-
x <<- x+1
return(x)
}
)
}
# initialize a new counter
cnt <- counter()
# call the counter with a bolded figure caption
cap <- function(str) {
paste("**Figure", cnt(), ":**",str)
}
from sklearn.datasets import load_boston
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import Imputer
from sklearn.base import BaseEstimator
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Callable
from sklearn.impute import SimpleImputer
from pprint import pprint
import pandas as pd
plt.style.use('bmh')
